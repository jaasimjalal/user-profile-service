import { Request, Response, NextFunction } from 'express';\nimport { logger } from '../utils/logger';\n\nexport interface AppError extends Error {\n  statusCode?: number;\n  status?: string;\n  code?: string;\n  keyPattern?: Record<string, unknown>;\n}\n\nexport class HttpError extends Error implements AppError {\n  statusCode: number;\n  status: string;\n  code?: string;\n  keyPattern?: Record<string, unknown>;\n\n  constructor(message: string, statusCode: number = 500, code?: string) {\n    super(message);\n    this.statusCode = statusCode;\n    this.status = statusCode >= 400 && statusCode < 500 ? 'fail' : 'error';\n    this.code = code;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class NotFoundError extends HttpError {\n  constructor(message: string = 'Resource not found') {\n    super(message, 404, 'NOT_FOUND');\n  }\n}\n\nexport class ValidationError extends HttpError {\n  constructor(message: string = 'Validation failed') {\n    super(message, 400, 'VALIDATION_ERROR');\n  }\n}\n\nexport class UnauthorizedError extends HttpError {\n  constructor(message: string = 'Unauthorized') {\n    super(message, 401, 'UNAUTHORIZED');\n  }\n}\n\nexport class ForbiddenError extends HttpError {\n  constructor(message: string = 'Forbidden') {\n    super(message, 403, 'FORBIDDEN');\n  }\n}\n\nexport class ConflictError extends HttpError {\n  constructor(message: string = 'Conflict') {\n    super(message, 409, 'CONFLICT');\n  }\n}\n\n// 404 Not Found Handler\nexport const notFoundHandler = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n): void => {\n  const error = new NotFoundError(`Route ${req.originalUrl} not found`);\n  next(error);\n};\n\n// Global Error Handler\nexport const errorHandler = (\n  err: AppError | Error,\n  req: Request,\n  res: Response,\n  _next: NextFunction\n): void => {\n  let error = { ...err } as AppError;\n  \n  // Log the error\n  logger.error('Error occurred', {\n    message: err.message,\n    stack: err.stack,\n    url: req.originalUrl,\n    method: req.method\n  });\n\n  // Handle non-HttpError errors\n  if (!(err instanceof HttpError)) {\n    error = new HttpError(\n      process.env.NODE_ENV === 'production' \n        ? 'Something went wrong' \n        : err.message,\n      500,\n      'INTERNAL_SERVER_ERROR'\n    );\n  }\n\n  // Handle Mongoose validation errors (if using Mongoose)\n  if (error.name === 'ValidationError') {\n    error.statusCode = 400;\n    error.code = 'VALIDATION_ERROR';\n  }\n\n  // Handle duplicate key errors (MongoDB/Mongoose)\n  if (error.code === '11000') {\n    const field = Object.keys(error.keyPattern || {})[0];\n    error.statusCode = 409;\n    error.code = 'DUPLICATE_KEY';\n    error.message = `${field} already exists`;\n  }\n\n  // Handle JWT errors\n  if (error.name === 'JsonWebTokenError') {\n    error.statusCode = 401;\n    error.code = 'INVALID_TOKEN';\n  }\n\n  if (error.name === 'TokenExpiredError') {\n    error.statusCode = 401;\n    error.code = 'TOKEN_EXPIRED';\n  }\n\n  // Send response\n  res.status(error.statusCode || 500).json({\n    success: false,\n    error: error.message || 'Something went wrong',\n    ...(error.code && { code: error.code }),\n    ...(process.env.NODE_ENV === 'development' && {\n      stack: error.stack\n    })\n  });\n};"}